/**
 *
 *  　　　　　　　}:　　　　　 　 　 　 　 　 　 _､,r　､,,v　　　＼
 * 　　　　　　 /　　　　＼　　 　 　 ､,v'" ~　　　　　ﾟ~"''x､　＼
 * 　 　 　 　 / 　 　 　 　 　 　 ､r''"　　 ,, ､,v､x｡,,　　　　　~" ､,
 * 　　　　　　　　　　　 ...::::入,,"　　,,､イ: : : : : : : : :"'ﾐ､,
 * 　　　　　　　　　　...::::／ 　ｙ": : : : : : : : : :イ : : : : : : :"v　　　　'､
 * 　　　　　 }　　 ....:::::イ 　／.: :/: : :／: :／ 八: : : : : : : : :＼ 　　 ,"
 * 　　 　 　 j　　　　　/　,:': : : /: :／: ／ 　/: ハ: : }:＼: : : : :´､, ｫ
 * 　､'"~｀"ゞ　　　　　　 ,.: : : : : : : :イ≦"￣''　 ､;_:j : : : : : : : : ﾄﾐ
 * r"　　　　　ｵ彡　　　 {: : : {: : : Vfうか㍉　 　ル"＞ミ: : : : :!: !
 * ､　　　　　 ,"　　　　 人: :八.: :从 ヒツ　　　　　ん㍊: : : : : ﾘ j
 * ´､,,　　､ノ'′　-‐:彡/: : : : :＼ ヽ""　　　　 　 だﾝ 从: : : ｲﾚ
 * 　　"¨　. . : : : : : : : : : : : {: : : : : :)　　 　 　 '　 `¨ ノ: :ノ: : :人ヽ
 * 　　　／: ／: : : ／ : : : :八: : : : :ﾘ　　　`　ｰ　ｰ=彡:イ: : : : : : : :
 * 　 ／: : : : : : : : : : : : イ: : :): : : : :| ＼　　 　 　 イ : : }: : : :}: :ハ: }
 * 　,': : : {: : : :厂¨¨＜: 人: : : : : : : !　　　ｰ　 爪: :ｉ : : :} : : :ル: : :ｿ
 * 　{: : :八: ＞ 　 　 ／: : : : : : : : ﾘ　　　　　 {: : : i: : :r- ＜ ¨¨ヽ: : .
 * ..人: : ／　　 　／: : : : : i: : : : :八 　　／　〉ミ: i: r┴　　　ヽ　　V: :＼
 * 　　ｿ　　　　／: : : : : : : i: : ／　 　 　 　 ,"　＼:.r--　　　　　 ､　V: : : ＼
 * ／: :{ 　　　,':ｨ: /: : : ／ﾉ／　　　　 　 　 ,,　 　 λ ､　　　　　　∨i: : : : : : .
 * 　 /:{　　　　ル: : 彡" ≠＝==…-==＝彳　　 v´ ゝ冬。　　 　　　: : : : : :
 * 　. :∧　　 /: : :／"　 　"s｡　　 　 　 　 亥　　;"　　　ヽミ　　　　 Y: : : : : : :}
 * .ノ: : 人　/: ／ 　 {　　　　ドx｡　　　 ｡ζ　　　､　　　　: :ﾊ　　　　 Ⅳ: : : : :人
 * : : : : : :У: '　　　　､　　　 ';　 ≫≪ﾟ゜　;　　　 ;" 　　　　}:＾j　　　　i "､:ルｲ: : ＼
 * : : : : : (: :({　　　　 ;"　　　ｼﾞﾟ゜　.::　ヾ｡,"　　　",　　　　: ;"" ､,　　 i　 "; :八: :}
 * : :!: : :ハ:.入　　　　v　　　;"　　.::::..　　`;　　　　"､　　人{､　　　"､,,　 　)
 * V{: : : : : 　 ゝ 　 　 j　　　､ 　ノ　　＼　";　　　 　χ　　 〉"､,,　　　 ",､
 * 　 ､: : : Y¨¨≫＞　_)　 　,ж"　　　　 ,,ゞ''::.. -‐　　".､　/　　　"､,,　　　"
 * 　　ヽ: :∧〃 　 　 ", 　 π＿ﾟ≫=≦ﾟ＿　"､　　　　　V　　　　　 "､,,　　"､
 * 　　　V　　　　　　　''､　 ド¨　　　　 　　¨＝≧､,
 * 　　　　　 } 　 　 　 　 y"　　　　　　　　　　　　"､,_　　{　　　　　　　}"　　 ,"
 * 　　 　 　 { 　 　 　 　 ヽ　　　　　　;i　　 　 　 　 　 '`~え
 * 　　　　 　 　 　 　 　 ＼､　　　　　　　　　　　　　,'` ~　　", 　 　 　 }　　　;"
 * 　　　　　　V　　　 　 　 ＼　　　　　　　　　,,'` ~　　　　　　",
 * 　　　　　　　　　　　　　　 ∧"''　 ､＿,､"~　　　　　　　　　　")彡'　　　　;"
 * 　　　 　 　 ｊ　　　 　 　 　 　 j=＝¨天⌒ミo｡　　　　､,,v '`"~　＼　　　r'"
 * 　　　　　　　　　　　　　 　,,､'" ､｡彳 ヾ 　　　》'` "~　　 　 　 　､ ヽ､,v"
 * 　　　　　 /　　　 　 ,,r ､v~ 　 　 "i{ 　 》添冬　　　　　　　,,　'`　~ "ｙ
 * 　　　　　　　　r ､v~　　　　　　 　 "y 侔愛翔
 * 　　　　　　 ,,＾"　　　 　 　 　､,"＾　＼ ゞ趁彡'　　　　,''｀　　　f"~
 * 　　　〈　 r"　　　　　 　 　 　)i　 　 　 ヽ　 　 　 　 ,,'｀　 　 ,''｀i
 * 　　　　　j　　　..:::'′ ,､　　 '"|
 * 　　　　Y　　　 ",,　,,＾　　　 　i　　　　　､ .)　､ｒ~　 　,､ｒ~ 　 　j
 * 　　　　　　 　 彡ｨ"　　　　　　`-ヽ_ゝ しY,`~　　ｖ "
 * 　　　　　"､　　 ､j　　　　　　　　　 　 　 ;i＾　`~
 * 　　 　 　 　 "　 ~|　　　 　 　 　 　 　 　 i|　　　　　　　　　　/
 *
 * Byakuren - A theme color extracting library implemented by C.
 *
 * Copyright (c) 2018 XadillaX <i@2333.moe>
 *
 * MIT LIcense <https://github.com/XadillaX/byakuren/blob/master/LICENSE>
 */
#include "octree.h"
#include <stdio.h>
#include <stdlib.h>

xmem_pool_handle _node_pool = 0;
xmem_pool_handle _reducible_pool = 0;

int _bkr_init_octree_env()
{
    if(!_node_pool) 
    {
        _node_pool = xmem_create_pool(sizeof(bkr_octree_node));
    }

    if(!_reducible_pool)
    {
        _reducible_pool = xmem_create_pool(sizeof(bkr_octree_reducible_list_node));
    }

    return _node_pool && _reducible_pool;
}

void _bkr_destroy_octree_env()
{
    SAFE_DESTROY_POOL(_node_pool);
    SAFE_DESTROY_POOL(_reducible_pool);
}

int _bkr_octree_add_color(bkr_octree_node* node, bkr_rgb* color,
        int level, uint32_t* leaf_count, bkr_octree_reducible_list_node* reducible[])
{
    if(node->is_leaf && node->is_leaf != 0xff)
    {
        node->pixel_count++;
        node->red_components   += color->red;
        node->green_components += color->green;
        node->blue_components  += color->blue;
        return 1;
    }
    else
    {
        /**
         * eg.
         *   R: 10101101
         *   G: 00101101
         *   B: 10010010
         *
         * idx: 50616616
         */
        uint8_t red   = (color->red   >> (7 - level)) & 1;
        uint8_t green = (color->green >> (7 - level)) & 1;
        uint8_t blue  = (color->blue  >> (7 - level)) & 1;
        int idx       = (red << 2) + (green << 1) + blue;

        if(!node->children[idx])
        {
            bkr_octree_node* tmp = node->children[idx] = (bkr_octree_node*)xmem_alloc(_node_pool);

            // can't allocate memory for a new node
            if(!tmp) return 0;

            if(level == 7)
            {
                tmp->is_leaf = 1;
                (*leaf_count)++;
            }
            else
            {
                // add this node to current level's
                // reducible list
                bkr_octree_reducible_list_node* reducible_node = (bkr_octree_reducible_list_node*)xmem_alloc(_reducible_pool);

                // can't create any more reducible node, we return an error
                if(!reducible_node) return 0;

                reducible_node->node = tmp;
                reducible_node->next = reducible[level];
                reducible[level]     = reducible_node;
            }
        }

        return _bkr_octree_add_color(
                node->children[idx],
                color, level + 1,
                leaf_count, reducible);
    }
}

void _bkr_octree_reduce(uint32_t* leaf_count,
        bkr_octree_reducible_list_node* reducible[])
{
    int lv = 6;

    // find the lowest and not empty reducible list
    while(!reducible[lv] && lv >= 0) lv--;
    if(lv < 0) return;

    // get the lowest level's first reducible node,
    // and replace the list head with it's next node
    bkr_octree_node* node = reducible[lv]->node;
    reducible[lv]         = reducible[lv]->next;

    int r = 0, g = 0, b = 0;
    int count = 0;
    int i;
    for(i = 0; i < 8; i++)
    {
        if(!node->children[i]) continue;
        r     += node->children[i]->red_components;
        g     += node->children[i]->green_components;
        b     += node->children[i]->blue_components;
        count += node->children[i]->pixel_count;

        // reduce one leaf
        (*leaf_count)--;

        // recover the node
        xmem_free(_node_pool, (char*)(node->children[i]));
        node->children[i] = 0;
    }

    // set the value of upper level's node
    node->is_leaf          = 1;
    node->red_components   = r;
    node->green_components = g;
    node->blue_components  = b;
    node->pixel_count      = count;

    // add one leaf
    (*leaf_count)++;
}

void bkr_release_octree(bkr_octree_node* node)
{
    // release this node's each children
    int i;
    for(i = 0; i < 8; i++)
    {
        if(node->children[i]) bkr_release_octree(node->children[i]);
    }

    // release itself
    xmem_free(_node_pool, (char*)node);
}

/**
static inline void _bkr_print_reducible(bkr_octree_reducible_list_node* list[])
{
    printf("[");
    for(int i = 0; i < 7; i++)
    {
        int count = 0;
        bkr_octree_reducible_list_node* node = list[i];
        while(node)
        {
            count++;
            node = node->next;
        }
        printf("%d", count);
        if(i != 0) printf(",");
    }
    printf("]");
}
*/

bkr_octree_node* bkr_build_octree(bkr_rgb* pixels, uint32_t pixel_count, uint32_t max_colors)
{
    bkr_octree_node* root = (bkr_octree_node*)xmem_alloc(_node_pool);

    // can't allocate memory for a new node
    if(!root) return 0;
    root->is_leaf = 0xff;

    uint32_t leaf_count = 0;

    // create an array contains
    // 7 reducible list.
    bkr_octree_reducible_list_node* _reducible_list[7];

    // 妈蛋，之前这句没写褚 bug 了！
    int i_;
    for(i_ = 0; i_ < 7; i_++) _reducible_list[i_] = 0;
    uint32_t i;
    for(i = 0; i < pixel_count; i++)
    {
        // for each pixel, we add this color to this octree
        // via function `_bkr_octree_add_color` with
        // updating `leaf_count` and `_reducible_list`
        if(!_bkr_octree_add_color(root, pixels + i, 0, &leaf_count, _reducible_list))
        {
            bkr_release_octree(root);
            return 0;
        }

        // after adding, we should calculate whether leaf_count is greater
        // than max_colors.
        // if it's true, we should reduce this octree.
        while(leaf_count > max_colors)
        {
            _bkr_octree_reduce(&leaf_count, _reducible_list);
            //_bkr_print_reducible(_reducible_list);
        }
    }

    return root;
}

int bkr_octree_calculate_color_stats(bkr_octree_node* node, bkr_color_stats stats[])
{
    static uint32_t stats_size = sizeof(bkr_color_stats);
    if(node->is_leaf && node->is_leaf != 0xff)
    {
        int r = node->red_components / node->pixel_count;
        int g = node->green_components / node->pixel_count;
        int b = node->blue_components / node->pixel_count;

        stats[0].count       = node->pixel_count;
        stats[0].color.red   = r;
        stats[0].color.green = g;
        stats[0].color.blue  = b;
        stats[0].value       = BKR_RGB_TO_INT32(r, g, b);

        return 1;
    }

    int _count = 0;
    int i;
    for(i = 0; i < 8; i++)
    {
        if(NULL != node->children[i])
        {
            _count += bkr_octree_calculate_color_stats(node->children[i], stats + _count);
        }
    }

    // if it's a root node
    if(node->is_leaf == 0xff)
    {
        qsort(stats, _count, stats_size, _stats_cmp);
    }

    return _count;
}
